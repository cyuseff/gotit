'use strict';

var aerospike = require('../../config/aero').aero
  , aero = require('../../config/aero').client
  , status = aerospike.status
  , uuid = require('uuid')
  , STATUS = require('../helpers/status-codes')
  , NAMESPACE = 'test'
  , SET = 'roles'
  , TTL = -1;

function generateAeroKey(primaryKey) {
  return aerospike.key(NAMESPACE, SET, primaryKey);
}

/*
  Rol Model:
    -id:            (uuid)    autogenerated if not provided
    -name:          (string)  required.
    -accessLevel:   (int)     used to filter the data in a endpoint. 1 is the highest access level.

    -routes:        (array <Object>) Ex:
                      -url: (string) Ex: '/provider/:scope/some-nested-route'
                      -methods: (string, array) Support for "*", "GET", "POST", "PUT" and "DELETE".
                      -recursive: (int). Default 0. If 1, allow user any route under.
                      -accessLevel: (string) Local accessLevel. Default: Rol accessLevel.
*/
function Rol(opts) {
  this.id = opts.id || uuid.v1();
  this.name = opts.name;
  this.accessLevel = opts.accessLevel || null;
  this.routes = opts.routes || [];
  this.createdAt = opts.createdAt || Date.now();
}


// Static Methods
Rol.findOneById = function(id, callback) {
  var key = generateAeroKey(id);

  aero.get(key, function(err, record, meta, key) {
    switch (err.code) {
      case status.AEROSPIKE_OK:
        callback(null, new Rol(record));
        break;
      case status.AEROSPIKE_ERR_RECORD_NOT_FOUND:
        callback(null, null);
        break;
      default:
        callback(err.message);
        break;
    }
  });
};

// ids = [];
Rol.findByIds = function(ids, callback) {
  var keys = []
    , roles = [];

  for(var i=0, l=ids.length; i<l; i++) keys.push(generateAeroKey(ids[i]));

  aero.batchGet(keys, function(err, results) {
    if(err.code !== status.AEROSPIKE_OK) return callback(err.message);

    for(i=0, l=results.length; i<l; i++) {
      if(results[i].status === status.AEROSPIKE_OK) {
        roles.push(results[i].record);
      } else {
        roles.push(null);
      }
    }
    return callback(null, roles);
  });
};

Rol.findAll = function(callback) {
  var filter, args, query, stream, roles;

  filter = aerospike.filter;
  args = {
    nobins: false,
    concurrent: true,
    filters: [filter.range('createdAt', 0, Date.now())]
  };

  roles = [];
  query = aero.query(NAMESPACE, SET, args);
  stream = query.execute();
  stream
    .on('data', function(record) { roles.push(record.bins); })
    .on('error', function(err) { return callback(err); })
    .on('end', function(end) { callback(null, roles); });
};

Rol.remove = function(id, callback) {
  var key = generateAeroKey(id);

  aero.remove(key, function(err, key) {
    if(err.code === status.AEROSPIKE_ERR_RECORD_NOT_FOUND) return callback({error: 'Rol not found', status: 404});
    if(err.code !== status.AEROSPIKE_OK) return callback(err.message);
    return callback(null, 1);
  });
};


// Instance Methods
Rol.prototype.addRoute = function(url, methods, recursive, accessLevel) {
  accessLevel = accessLevel || this.accessLevel;
  recursive = 1; // 0 | 1

  if(url && methods) {
    this.routes.push({
      url: url,
      methods: methods,
      recursive: recursive,
      accessLevel: accessLevel
    });
  }
};

Rol.prototype.save = function(callback) {
  var me = this
    , key = generateAeroKey(me.id);

  aero.put(key, me, {ttl: TTL}, function(err, key) {
    if(err.code !== aerospike.status.AEROSPIKE_OK) if(callback) return callback(err.message, null);
    if(callback) return callback(null, key);
  });
};

module.exports = Rol;
